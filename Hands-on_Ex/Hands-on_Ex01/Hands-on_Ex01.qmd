---
title: "Hands-on Exercise 1"
author: "Deng Yiqi"
date: "September 1, 2025"
date-modified: "last-modified"
format: 
  html:
    toc-depth: 4
    toc-expand: true
execute:
  eval: true
  echo: true
  warning: false
  freeze: true
---

# Part1 Overview

## Getting started

### Install and launching R packages

```{r}
pacman::p_load(sf, tidyverse)
```

## Importing Geospatial Data

```{r}
mpsz <- st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")

cyclingpath <- st_read("data/geospatial/CyclingPath_Apr2025/CyclingPathGazette.shp")

preschool <- st_read("data/geospatial/PreSchoolsLocation.geojson")

```

## Checking the Content of A Simple Feature Data Frame

### Working with st_geometry()

```{r}
st_geometry(mpsz)
```

### Working with glimpse()

```{r}
glimpse(mpsz)
```

### Working with head()

```{r}
head(mpsz, n=5)  
```
## Plotting the Geospatial Data

```{r}
plot(mpsz)

plot(st_geometry(mpsz))

plot(st_geometry(mpsz))
plot(st_geometry(preschool), 
     add = TRUE)

```
## Working with Projection
### Assigning EPSG code to a simple feature data frame
```{r}
st_crs(mpsz)
mpsz <- st_set_crs(mpsz, 3414)
st_crs(mpsz)
```

### Transforming the projection of preschool from wgs84 to svy21.

```{r}
preschool <- st_transform(preschool, 
                              crs = 3414)
```

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(preschool), add = TRUE)
```
## Importing and Converting An Aspatial Data

### Importing the aspatial data

```{r}
listings <- read_csv("data/aspatial/listings.csv")
list(listings) 
```

### Creating a simple feature data frame from an aspatial data frame

```{r}
listings_sf <- st_as_sf(listings, 
                       coords = c("longitude", "latitude"),
                       crs=4326) %>%
  st_transform(crs = 3414)

glimpse(listings_sf)
```

## Geoprocessing with sf package
### Use case 1: Land acquisition analysis

```{r}
buffer_cycling <- st_buffer(
  cyclingpath, dist=5, nQuadSegs = 30)

buffer_cycling$AREA <- st_area(buffer_cycling)

buffer_cycling <- buffer_cycling %>%
  mutate(AREA = st_area(geometry))

sum(buffer_cycling$AREA)
# Examine the 'Description' column to see how subzone names are represented
head(mpsz$Description)

# If subzone names are in Description, extract them using string manipulation
mpsz <- mpsz %>%
  mutate(SUBZONE_NAME = str_extract(Description, "SUBZONE_NAME_PATTERN"))  # Replace with appropriate pattern

# Now filter by subzone name
mpsz_selected <- mpsz %>%
  filter(SUBZONE_NAME == "TAMPINES WEST")

# Check CRS of both datasets
st_crs(buffer_cycling)
st_crs(mpsz_selected)

# Reproject buffer_cycling to match the CRS of mpsz_selected
buffer_cycling <- st_transform(buffer_cycling, st_crs(mpsz_selected))

# Perform the intersection
buffer_cycling_selected <- st_intersection(buffer_cycling, mpsz_selected)

# View the result
head(buffer_cycling_selected)
```

### Use case 2: To determine the number of pre-schools by planning subzone
```{r}
mpsz$`PreSch Count`<- lengths(st_intersects(mpsz, preschool))
summary(mpsz$`PreSch Count`)
top_n(mpsz, 1, `PreSch Count`)
mpsz$Area <- mpsz %>%
  st_area()
mpsz <- mpsz %>%
  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)
hist(mpsz$`PreSch Density`)
ggplot(data=mpsz, 
       aes(x= as.numeric(`PreSch Density`)))+
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(title = "Are pre-school even distributed in Singapore?",
       subtitle= "There are many planning subzones with a single pre-school, on the other hand, \nthere are seven planning subzones with at least 30 or more pre-schools",
      x = "Pre-school density (per km sq)",
      y = "Frequency")
ggplot(data=mpsz, 
       aes(y = `PreSch Count`, 
           x= as.numeric(`PreSch Density`)))+
  geom_point(color="black", 
             fill="light blue") +
  xlim(0, 40) +
  ylim(0, 40) +
  labs(title = "",
      x = "Pre-school density (per km sq)",
      y = "Pre-school count")
```

# Part2 Overview

## Getting started

### Install and launching R packages

```{r}
pacman::p_load(sf, tmap, tidyverse, rvest)
```

## Importing Data into R
### Importing Geospatial Data into R

```{r}
mpsz <- st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")
```
Tidying data
```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
mpsz <- mpsz %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())
```

```{r}
mpsz
```

### Importing Attribute Data into R

```{r}
popdata <- read_csv("data/aspatial/respopagesextod2024.csv")
```
### Data Preparation

```{r}
popdata2024 <- popdata %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)
```

```{r}
popdata2024 <- popdata2024 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = list(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

```{r}
mpsz_pop2024 <- left_join(mpsz, popdata2024,
                          by = c("SUBZONE_N" = "SZ"))
```

## Choropleth Mapping Geospatial Data Using tmap
### Plotting a choropleth map quickly by using qtm()

```{r}
tmap_mode("plot")
qtm(shp = mpsz_pop2024, 
    fill = "DEPENDENCY")
```

### Creating a choropleth map by using tmapâ€™s elements
```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_title("Distribution of Dependency Ratio by planning subzone") +
  tm_layout(frame = TRUE) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```
Drawing a base map

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons()
```

Drawing a choropleth map using tm_polygons()

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY")
```

Drawing a choropleth map using tm_fill() and *tm_border()**

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY")
```

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders()
```

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders(col = "grey60",
             lwd = 0.1,
             lty = "dashed")
```

### Data classification methods of tmap

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

Plotting choropleth map with custome break

```{r}
summary(mpsz_pop2024$DEPENDENCY)
```

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00))) +
  tm_borders(fill_alpha = 0.5)
```

### Colour Scheme
```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```

Cartographic Furniture

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

### Map Layout

Map Legend

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_pos_auto_in() +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```
Map style

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) + 
  tm_borders(fill_alpha = 0.5) + 
  tmap_style("natural")
tmap_style("white")
```
## Drawing Small Multiple Choropleth Maps
### By assigning multiple values to at least one of the aesthetic arguments

```{r}
tm_shape(mpsz_pop2024) + 
  tm_polygons(
    fill = c("YOUNG", "AGED"),
    fill.legend = 
      tm_legend(position = tm_pos_in(
        "right", "bottom")),
    fill.scale = tm_scale_intervals(
      style = "equal", 
      n = 5,
      values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tmap_style("natural")
```

### By arrange multiples choropleth maps in a grid layout

```{r}
youngmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "YOUNG",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                  item.height = 0.8),
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of young population")
                
agedmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "AGED",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                item.height = 0.8),
              fill.scale = tm_scale_intervals(
              style = "quantile", 
              values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of aged population")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```
### By defining a group-by variable in tm_facets()

```{r}
tm_shape(mpsz_pop2024) +
  tm_fill(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile",
            values = "brewer.blues")) + 
  tm_facets(by = "REGION_N",
            nrow = 2, 
            ncols = 3,
            free.coords=TRUE, 
            drop.units=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(fill_alpha = 0.5)
```

## Mappping Spatial Object Meeting a Selection Criterion

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend()) +
  tm_borders(fill_alpha = 0.5)
```

## Complementing Thematic Map with Statistical Chart

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend(),
              fill.chart = tm_chart_box()) +
  tm_borders() +
  tm_layout(asp = 0.8)
```

```{r}
mpsz_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")

stats <- boxplot.stats(mpsz_selected$DEPENDENCY)

outlier_vals <- stats$out

outlier_sf <- mpsz_selected[mpsz_selected$DEPENDENCY %in% outlier_vals, ]

tm_shape(mpsz_selected) +
  tm_polygons(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile", 
            values = "brewer.blues"),
          fill.legend = tm_legend(),
          fill.chart = tm_chart_box()) +
  tm_borders(fill_alpha = 0.5) +
tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_text("SUBZONE_N", col = "red", size = 0.7) +
  tm_layout(asp = 0.8)
```

## Creating Interactive Map

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")
tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2)
```

```{r}
tmap_mode("plot")
```

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")

tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_view(set_zoom_limits = c(12,14))
```

```{r}
tmap_mode("plot")
```
